_Z9fibonaccii:          # Манглированное имя функции (fibonacci(int))
.LFB0:                  # Метка начала функции
    pushq   %rbp        # Сохраняем предыдущее значение указателя базы
    movq    %rsp, %rbp  # Устанавливаем новый указатель базы
    subq    $16, %rsp   # Выделяем 16 байт в стеке для локальных переменных
    
    # Сохранение параметра n в стеке
    movl    %edi, -4(%rbp)  # Параметр n сохраняется по адресу [rbp-4]
    
    # Проверка условия n <= 1
    cmpl    $1, -4(%rbp)    # Сравниваем n с 1
    jg      .L2             # Если n > 1, переходим к метке .L2
    
    # Случай n <= 1 (возвращаем n)
    movl    -4(%rbp), %eax  # Загружаем n в регистр eax (возвращаемое значение)
    jmp     .L3             # Переходим к завершению функции
    
.L2:    # Рекурсивный случай
    # Первый рекурсивный вызов (fibonacci(n-1))
    movl    -4(%rbp), %eax  # Загружаем n в eax
    subl    $1, %eax         # Вычисляем n-1
    movl    %eax, %edi       # Передаем n-1 как параметр
    call    _Z9fibonaccii    # Вызываем fibonacci(n-1)
    movl    %eax, -8(%rbp)   # Сохраняем результат в стеке [rbp-8]
    
    # Второй рекурсивный вызов (fibonacci(n-2))
    movl    -4(%rbp), %eax  # Снова загружаем n
    subl    $2, %eax         # Вычисляем n-2
    movl    %eax, %edi       # Передаем n-2 как параметр
    call    _Z9fibonaccii    # Вызываем fibonacci(n-2)
    
    # Суммирование результатов
    movl    -8(%rbp), %edx  # Загружаем fibonacci(n-1) в edx
    addl    %edx, %eax       # Складываем с fibonacci(n-2) (результат уже в eax)
    
.L3:    # Выход из функции
    leave          # Эквивалентно movq %rbp, %rsp; popq %rbp
    ret           # Возврат из функции
